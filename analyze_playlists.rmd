---
title: "How similar (or not) are WFMU DJs?"
output: html_notebook
author: Arthur Steinmetz
---
 

```{r, message=FALSE, warning=FALSE}


library(devtools)
#install_github('sinhrks/ggfortify')
library(ggplot2)
library(stringr)
library(tm)
library(dplyr)
library(tidyverse)
library(lubridate)
library(xts)
library("ggplot2")
#library(ggfortify)
library("wordcloud")
library("RColorBrewer")
library("SnowballC")
library(igraph)
library(cluster)
# library(reshape2)
library(vegan)
library(Matrix)

load("playlists_raw.Rdata")
load("djkey.Rdata")

DJKey<-as_tibble(DJKey) %>% mutate(DJ=as.factor(DJ))
```

Clean up inconsistant artist names
```{r}

playlists<-playlists_raw %>% 
  distinct() %>% 
  filter(Artist != Title)

playlists$ArtistToken<-playlists$Artist
# one artist is all punctuation so give !!! special treatment
playlists$ArtistToken<-str_replace(playlists$ArtistToken,"!!!","chkchkchk")
# now change some common punctuation to space
print("Stripping Punctuation")

playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"\\&"," ")

playlists$ArtistToken<-str_to_lower(playlists$ArtistToken)
# I choose to strip out the stuff below though dealing with it might get better analysis
#remove any text in parentheses
print("Stripping filler words")
# get rid of anything between parenthesis
#tricky regex to handle cases of multiple parentheticals in one artist
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"(\\([^(]+\\))","")
# remove 'featuring' or 'with' artists
# I chose not to remove "Versus" because that is a band name
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"(feat |featuring |and the |with |vs |vs\\.).+","")
# get rid of 'live' identifier
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"(live @ |live on|@).+","")

#now get rid of remaining non-word characters except space

playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"[^a-z^ ^0-9]","")


# get rid of 'interview'
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"(interview w|interview)","")

# get rid of unspecified artists
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"unknown artist(s| )|unknown","")
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"various artists|various","")

#get rid of the marathon finale
playlists<-playlists%>%filter(!str_detect(Artist,"hoof[a-zA-Z ]+sinfonia"))

#make "new york" one word.  Lots of bands start with the term
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"new york","newyork")

#make "x ray" one word. hopefully we've stripped out the dash already.Lots of bands start with the term
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"x ray","xray")

#now some connecting words that might be spelled/used variantly
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"and | of | the "," ")

#and leading "the"
playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"^the "," ")
# strip leading/trailing whitespace
playlists$ArtistToken<-str_trim(playlists$ArtistToken)

#did we create any null entries
playlists<-filter(playlists,Artist!="")
playlists<-filter(playlists,Artist!="Artist")

playlists<- filter(playlists,!str_detect(Artist, "Music Behind Dj:"))
playlists<- filter(playlists,!str_detect(Artist, "Wake N Bake"))


numWords=2 #is two enought for uniqueness?

  # we replaced all punctuation with spaces
  #maybe strip spaces and combine all artist Words
  #combine first two words
  print("Trying to make sense of artist names")
  #does this break if numWords> number of words?
  t<-str_split_fixed(playlists$ArtistToken,pattern="[ ]+",n=numWords+1)[,1:numWords]
  
  playlists$ArtistToken<-apply(t,MARGIN=1,FUN=paste,collapse="")

  # There are a dozen ways Andy Breckman can misspell "Bruce Springsteen."
  playlists<- playlists %>%   
    mutate(ArtistToken=replace(ArtistToken,
                               str_detect(ArtistToken,'brucesp'),
                               "springsteen"))
  
  #Code below used for unique list of artists. Not used here.
  #now that tokens are created extract unique ones for each dj so mulitples don't occur
  # the zillion flavors of "Sun Ra..." will show up for each DJ only once
  # not perfect.  There are a dozen ways Andy Breckman can misspell "Bruce Springsteen."
  #print("Create list of unique artist names for each DJ")
  #artistTokens<-playlists%>%select(DJ,artistToken)%>%group_by(DJ)%>%distinct(artistToken)


  print("Combining iconic 2-name artists into one name to save space in wordcloud")
  playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"rollingstones","stones")
  playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"enniomorricone","morricone") #only on WFMU!
  playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"davidbowie","bowie")
  playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"bobdylan","dylan")
  playlists$ArtistToken<-str_replace_all(playlists$ArtistToken,"yola","yolatengo")
  
  playlists<-playlists %>% 
    mutate(DJ=as.factor(DJ)) %>%
    filter(ArtistToken !="") %>% 
    filter(ArtistToken !="yourdj") %>% 
    filter(ArtistToken !="hoofmouth") %>% 
    filter(ArtistToken !="tomwilson") %>%  #not songs
    filter(ArtistToken !="hanklevine") %>%  #not songs
    distinct() %>% #why would there be dupes?  Don't know, but there are
    group_by(DJ) 
```

```{r}
  #do we want to strip the signature song the some DJs use to open every show?
  #Their high play count distorts the popularity of some artists.
  #Remove songs that have more than 20 instances of being the first song played.
  #NOTE: This will remove all instances of that song title played by any DJ.
  songs_to_strip<-playlists %>% 
    group_by(DJ,AirDate) %>% 
    summarize(FirstSong=first(Title)) %>% 
    group_by(FirstSong) %>% 
    summarise(FirstPlayCount=n()) %>% 
    arrange(desc(FirstPlayCount)) %>%
    filter(FirstPlayCount>20,FirstSong != "Track 1",FirstSong != "Untitled")

playlists<- playlists %>% filter(!(Title %in% songs_to_strip$FirstSong))

songs_to_strip
```
Data is reasonably clean.  Do some analysis
```{r}

#playlists_raw by year
playlists %>% 
  ungroup() %>% 
  mutate(Year=trunc(decimal_date(AirDate)))  %>% 
  group_by(Year) %>% 
  summarise(SongCount=n()) %>% 
  arrange(Year) %>% 
  filter(Year > 1979) %>% 
  ggplot(aes(x=Year,y=SongCount))+geom_col()+labs(title="Songs Streamed or Aired at WFMU.ORG",x="Airdate")



```
```{r}

#playlists_raw by year
playlists %>% 
  ungroup() %>% 
  mutate(Year=trunc(decimal_date(AirDate)))  %>% 
  select(DJ,AirDate,Year) %>% 
  distinct() %>% 
  group_by(Year) %>% 
  summarise(ShowCount=n()) %>% 
  arrange(Year) %>% 
  filter(Year > 1979) %>% 
  ggplot(aes(x=Year,y=ShowCount))+geom_col()+labs(title="Shows Archived at WFMU.ORG by Airdate",x="Airdate")



```

```{r, message=FALSE, warning=FALSE}

#-------------------------------------------------------------------------------------
# We love wordclouds!
#scalefactor magnifies differences for wordcloud
#use filters to select on or off schedule and constrain show airdate range
scaleFactor=2
maxWords = 200
  #most popular artists
  top_artists<-DJKey %>% 
    filter(onSched==TRUE) %>% #on Sched or off?
    left_join(playlists)%>%
    group_by(ArtistToken)%>%
    #filter(AirDate<as.Date("2017-03-18")) %>%  #date range?
    summarize(play_count=n())%>%
    arrange(desc(play_count))
wordcloud(words = top_artists$ArtistToken, freq = top_artists$play_count^scaleFactor,max.words=maxWords, random.order=FALSE,rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"),scale = c(3,.3))

```
NRBQ?  How many DJ's play them in any given quarter?  Not many, it seems.
```{r}
artist_token='nrbq'
cutoff_date=as.Date("2007-01-01")

dj_count<-playlists %>% 
  ungroup() %>% 
  filter(ArtistToken==artist_token) %>% 
  filter(AirDate > cutoff_date) %>% 
  mutate(YrQtr=as.yearqtr(AirDate))  %>% 
  group_by(DJ,YrQtr) %>% 
  summarise(Spins=n()) %>% 
  arrange(YrQtr) %>% 
  group_by(YrQtr) %>% 
  summarise(DJCount=n())

gg<-dj_count %>% ggplot(aes(x=YrQtr,y=DJCount))+geom_col()
gg<-gg+labs(title=paste("How many DJs Spin",artist_token,"every Quarter?"))
gg<-gg+scale_x_continuous()
gg
```
So maybe certain DJs account for most of the plays?
```{r, message=FALSE, warning=FALSE}
play_count_by_DJ<-playlists %>% 
  ungroup() %>% 
  filter(AirDate > cutoff_date) %>% 
  mutate(DJ=as.character(DJ)) %>% 
  filter(ArtistToken==artist_token) %>% 
  mutate(YrQtr=as.yearqtr(AirDate))  %>% 
  group_by(DJ,YrQtr) %>% 
  summarise(Spins=n()) %>% 
  arrange(YrQtr)

threshold <-5
pc1<- play_count_by_DJ %>% 
  filter(Spins>=threshold)

#lump together all DJ's who played the artist less than 'threshold' times
pc2<- play_count_by_DJ %>% 
  filter(Spins<threshold) %>% 
  group_by(YrQtr) %>% 
  summarise(Spins=n()) %>% 
  mutate(ShowName='AllOther')

play_count_by_DJ<-pc1 %>% 
  left_join(DJKey) %>% 
  bind_rows(pc2) %>% 
  select(YrQtr,ShowName,Spins)

gg<-play_count_by_DJ %>% ggplot(aes(x=YrQtr,y=Spins,fill=ShowName))+geom_col()
gg<-gg+labs(title=paste("Who accounts for the most",artist_token,"plays every quarter?"))
gg<-gg+scale_x_continuous()
gg
```
Bob Brainen is the NRBQ show. Contrast that to The Beach Boys, where interest is more spread around.
```{r, message=FALSE, warning=FALSE}
artist_token<-'beachboys'

play_count_by_DJ<-playlists %>% 
  ungroup() %>% 
  filter(AirDate > cutoff_date) %>% 
  mutate(DJ=as.character(DJ)) %>% 
  filter(ArtistToken==artist_token) %>% 
  mutate(YrQtr=as.yearqtr(AirDate))  %>% 
  group_by(DJ,YrQtr) %>% 
  summarise(Spins=n()) %>% 
  arrange(YrQtr)

threshold <-5
pc1<- play_count_by_DJ %>% 
  filter(Spins>=threshold)

#lump together all DJ's who played the artist less than 'threshold' times
pc2<- play_count_by_DJ %>% 
  filter(Spins<threshold) %>% 
  group_by(YrQtr) %>% 
  summarise(Spins=n()) %>% 
  mutate(ShowName='AllOther')

play_count_by_DJ<-pc1 %>% 
  left_join(DJKey) %>% 
  bind_rows(pc2) %>% 
  select(YrQtr,ShowName,Spins)

gg<-play_count_by_DJ %>% ggplot(aes(x=YrQtr,y=Spins,fill=ShowName))+geom_col()
gg<-gg+labs(title=paste("Who accounts for the most",artist_token,"plays every quarter?"))
gg<-gg+scale_x_continuous()
gg
```


#Dead Artist Effect. 

When did interest in an artist increase?
```{r}
dead_artists=c('bowie','prince','amywinehouse','sharonjones','chuckberry','allmanbrothers')

dead_artist_plays<-playlists %>% 
  ungroup() %>% 
  filter(AirDate > cutoff_date) %>% 
  filter(ArtistToken %in% dead_artists) %>% 
  mutate(YrQtr=as.yearqtr(AirDate))  %>% 
  group_by(ArtistToken,YrQtr) %>% 
  summarise(Spins=n()) %>% 
  arrange(YrQtr)
gg<-dead_artist_plays %>% ggplot(aes(x=YrQtr,y=Spins))
gg<-gg+geom_col()+facet_wrap(~ArtistToken)
gg<-gg+scale_x_continuous()+ggtitle("Dead Artist Effect")
gg
```
Prince is the prince but Bowie is the king.  The deaths of Prince and Davie Bowie led to some continuing interest in the artist, while plays for Chuck Berry, Sharon Jones and the Allman brothers dropped back to their pre-death background levels.  Amy Winehouse barely registers, before or after. To make this more visible, clip the y-axis at 100.
```{r}
#clip outliers
dead_artist_plays[dead_artist_plays$Spins>100,]$Spins=100

gg<-dead_artist_plays %>% ggplot(aes(x=YrQtr,y=Spins))
gg<-gg+geom_col()+facet_wrap(~ArtistToken)
gg<-gg+scale_x_continuous()+ggtitle("Dead Artist Effect")
gg


```

#Durability of popular artists

How much stability to the most popular artists have in the rotation?

```{r, message=FALSE, warning=FALSE}

big_artists=top_artists$ArtistToken[1:6]

artist_trends<-playlists %>% 
  ungroup() %>% 
  filter(AirDate > cutoff_date) %>% 
  filter(ArtistToken %in% big_artists) %>% 
  mutate(YrQtr=as.yearqtr(AirDate))  %>% 
  group_by(ArtistToken,YrQtr) %>% 
  summarise(Spins=n()) %>% 
  arrange(YrQtr)

#clip outliers
artist_trends[artist_trends$Spins>100,]$Spins=100

gg<-artist_trends %>% ggplot(aes(x=YrQtr,y=Spins))+geom_col()
gg<-gg+facet_wrap(~ArtistToken)
gg<-gg+scale_x_continuous()+ylim(0,100)
gg<-gg+labs(title="Durability of popular artists\nQuarterly Plays",caption="Outliers clipped to 100")
gg

```

combine artist list into a single string per DJ
```{r}
#-------------------------------------------------------------  
#combineAllArtists
  concat_artists<- data_frame()
  #make sure there aren't extra levels
  playlists$DJ<-factor(playlists$DJ,as.character(unique(playlists$DJ)))
  for (dj in levels(playlists$DJ)){
    #put all words in string for each DJ
    print(paste("Creating artist documents",dj))
    concat_artists<-bind_rows(concat_artists,data_frame(DJ=dj,
                        Artists= playlists%>%
                          filter(DJ==dj)%>%
                          pull(ArtistToken)%>% 
                          paste(collapse=" ")%>%
                          str_replace_all("[^a-z ]","")%>%as.character() ,
                          onSched=DJKey%>%filter(DJ==dj)%>%pull(onSched)
                        ))
  }
  #artists should not have factor levels
  #concat_artists$Artists<-as.character(concat_artists$Artists)
  concat_artists<-filter(concat_artists,Artists!="")


```
Create term document matrices
```{r}
print("Create document corpus and term document matrices")
djCorpus <- VCorpus(VectorSource(concat_artists$Artists))


for (i in 1:length(djCorpus)) {
  meta(djCorpus[[i]], tag="id") <- concat_artists$DJ[i]  
  meta(djCorpus[[i]], tag="DJ") <- concat_artists$DJ[i]
  meta(djCorpus[[i]], tag="onSched") <- (DJKey %>% 
    filter(DJ==concat_artists[1,1] %>% 
             pull()) %>% 
    pull(onSched))
}



#sched_status=c("on","off","all")
#status<-sched_status[1]
#idx <- switch(mic,
#              on = (meta(djCorpus, "onMic") == TRUE),
#              off = (meta(djCorpus, "onMic") == FALSE),
#              both = rep(TRUE,length(djCorpus))
#              )


#djtdm<-TermDocumentMatrix(djCorpus[idx])%>%removeSparseTerms(SPARSE)

#OR if you have the memory to pre-create
#make 3 Term Document Matrices where artist is in the column based on onmic status
#get roughly top 400 artists when removeSparseTerms(0.80) used. top 8000 when 0.95 sparse is used
SPARSE<- 0.95 #sparsity of term document matrices

# djtdm_all<-TermDocumentMatrix(djCorpus) #%>%removeSparseTerms(SPARSE)
# djtdm_on<-TermDocumentMatrix(djCorpus[meta(djCorpus, "onSched") == TRUE])%>%removeSparseTerms(SPARSE)
# djtdm_off<-TermDocumentMatrix(djCorpus[meta(djCorpus, "onSched") == FALSE])%>%removeSparseTerms(SPARSE)

# now create Document Term Matrix where DJs are the column
djdtm<-DocumentTermMatrix(djCorpus) %>%removeSparseTerms(SPARSE)
```

#Analyze similarity
```{r}
jaccard <- function(m) {
  #http://stackoverflow.com/questions/36220585/efficient-jaccard-similarity-documenttermmatrix
  ## common values:
  A <- tcrossprod(m)
  im <- which(A > 0, arr.ind=TRUE, useNames = FALSE)
  b <- rowSums(m)
  Aim <- A[im]
  J<-sparseMatrix(
    i = im[,1],
    j = im[,2],
    x = Aim / (b[im[,1]] + b[im[,2]] - Aim),
    dims = dim(A)
  )
  
  #preserve row/column names, if any
  rownames(J)<-rownames(m)
  colnames(J)<-rownames(m)
  return( J )
}  
#-----------------------------------------------------------
getSimilarity<-function(djdtm=djdtm){
  m2<-as.matrix(sign(djdtm))
  # get similarity
  j<-vegdist(m2,method="bray") %>% as.matrix()
  j<-1-j
  #j<-jaccard(m2)
  
  save(j,file="djSimilarity.RData")
  return(j)
}
#-----------------------------------------------------------


# get similarity index matrix using Jaccard
j<-getSimilarity(djdtm)

#cluster plot of DJs
set.seed(1)
CLUSTERS=5
  kdj<-kmeans(j,CLUSTERS)
  clust<-kdj$cluster
  #djCluster<-cbind(DJ=names(clust),data.frame(cluster=clust))
  
  #if ("cluster" %in% names(DJKey)){
  #  # then remove the cluster column
  #  DJKey<-select(DJKey,-cluster)
  #}
  # now replace with new clustering
  #DJKey<-inner_join(DJKey,djCluster)%>%arrange(cluster)
    
  
  clusplot(as.matrix(j), clust, main="DJ Similiarity Clusters",color=T, shade=T, labels=2, lines=0) 

```

```{r}
#----------------------------------------------------------
similarDJs<-function(whichDJ="TW",compareDJ="TM"){
  #djs for example
  #whichDJ <- "TW"
  #compareDJ<-"TM"
likeDJs<-data_frame(DJ=row.names(j),similarity=as.matrix(j)[,whichDJ]) %>% 
  arrange(desc(similarity)) #sort descending and remove self DJ

  #since we sorted in order of descending similarity the first row has the most similar DJ
  compareDJ<-likeDJs[1:3,1] %>% pull() 
  whichShow<-DJKey%>%filter(DJ==whichDJ)%>%.$ShowName%>%as.character()
  compareShow<-DJKey%>%filter(DJ %in% compareDJ)%>%.$ShowName%>%as.character()
  print(paste(whichShow,"is most similar to",compareShow))
  print(paste("Similarity Index:",format(pull(likeDJs[1:3,2]),digits=2),"/1.00"))
  
  commonArtists<-intersect(artistTokens[which(artistTokens$DJ==whichDJ),]$artistToken,artistTokens[which(artistTokens$DJ==compareDJ),]$artistToken)
  print(data.frame(Common_Artists=sample(commonArtists,20)))
}

similarDJs()
```

```{r}
likeDJs<-djdtm %>%
  as.matrix() %>% 
  vegdist(method="bray") %>% 
  as.matrix() %>% 
  as.data.frame() %>% 
  mutate(DJ1=rownames(.)) %>% 
  as_tibble() %>% 
  gather(DJ2,Similarity,-DJ1) %>% 
  mutate(Similarity=1-Similarity) %>% 
  filter(DJ1 != DJ2) %>%  #remove diagonals
  group_by(DJ1) %>% 
  arrange(desc(Similarity))

dj1 <- "TW"
dj2 <- "TM"

likeDJs %>% 
  ungroup() %>% 
  filter(DJ1==dj1) %>% 
  .[1:3,] %>% 
  rename(DJ=DJ2) %>% 
  left_join(DJKey) %>% 
  select(ShowName,Similarity)


songs1 <-playlists %>% 
  filter(DJ==dj1) %>% 
  group_by(ArtistToken) %>% 
  summarise(plays=n()) %>% 
  arrange(desc(plays))
songs2 <-playlists %>% 
  filter(DJ==dj2) %>% 
  group_by(ArtistToken) %>% 
  summarise(plays=n())%>% 
  arrange(desc(plays))

inner_join(songs2,songs1,by='ArtistToken') %>% 
  mutate(FaveIndex=plays.x+plays.y-abs(plays.x-plays.y)) %>% 
  arrange(desc(FaveIndex))
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).
