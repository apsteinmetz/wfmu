---
title: "How similar (or not) are WFMU DJs?"
output: html_notebook
author: Arthur Steinmetz
---
 

```{r}


library(devtools)
#install_github('sinhrks/ggfortify')
library(ggplot2)
library(stringr)
library(tm)
library(dplyr)
library("ggplot2")
#library(ggfortify)
library("wordcloud")
library("RColorBrewer")
library("SnowballC")
library(igraph)
library(cluster)
library(reshape2)
library(proxy)
library(Matrix)

load("playlists.Rdata")
load("djkey.Rdata")

```

Clean up inconsistant artist names
```{r}

allDJArtists<-playlists

allDJArtists$ArtistRaw<-allDJArtists$Artist
# one artist is all punctuation so give !!! special treatment
allDJArtists$Artist<-str_replace(allDJArtists$Artist,"!!!","chkchkchk")
# now change some common punctuation to space
print("Stripping Punctuation")

allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"\\&"," ")

allDJArtists$Artist<-str_to_lower(allDJArtists$Artist)
# I choose to strip out the stuff below though dealing with it might get better analysis
#remove any text in parentheses
print("Stripping filler words")
# get rid of anything between parenthesis
#tricky regex to handle cases of multiple parentheticals in one artist
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"(\\([^(]+\\))","")
# remove 'featuring' or 'with' artists
# I chose not to remove "Versus" because that is a band name
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"(feat |featuring |and the |with |vs |vs\\.).+","")
# get rid of 'live' identifier
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"(live @ |live on|@).+","")

#now get rid of remaining non-word characters except space

allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"[^a-z^ ^0-9]","")


# get rid of 'interview'
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"(interview w|interview)","")

# get rid of unspecified artists
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"unknown artist(s| )|unknown","")
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"various artists|various","")

#get rid of the marathon finale
allDJArtists<-allDJArtists%>%filter(!str_detect(Artist,"hoof[a-zA-Z ]+sinfonia"))

#make "new york" one word.  Lots of bands start with the term
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"new york","newyork")

#make "x ray" one word. hopefully we've stripped out the dash already.Lots of bands start with the term
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"x ray","xray")

#now some connecting words that might be spelled/used variantly
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"and | of | the "," ")

#and leading "the"
allDJArtists$Artist<-str_replace_all(allDJArtists$Artist,"^the "," ")
# strip leading/trailing whitespace
allDJArtists$Artist<-str_trim(allDJArtists$Artist)

#did we create any null entries
allDJArtists<-filter(allDJArtists,Artist!="")
allDJArtists<-filter(allDJArtists,Artist!="Artist")

allDJArtists<- filter(allDJArtists,!str_detect(Artist, "Music Behind Dj:"))
allDJArtists<- filter(allDJArtists,!str_detect(Artist, "Wake N Bake"))

```

```{r}
#-----------------------------------------------------------------------------
#combine Artist Words into single token
numWords=2 #is two enought for uniqueness?

  # we replaced all punctuation with spaces
  #maybe strip spaces and combine all artist Words
  #combine first two words
  print("Trying to make sense of artist names")
  #does this break if numWords> number of words?
  t<-str_split_fixed(allDJArtists$Artist,pattern="[ ]+",n=numWords+1)[,1:numWords]
  
  allDJArtists$ArtistToken<-apply(t,MARGIN=1,FUN=paste,collapse="")

  # There are a dozen ways Andy Breckman can misspell "Bruce Springsteen."
  allDJArtists<- allDJArtists %>%   
    mutate(ArtistToken=replace(ArtistToken,
                               str_detect(ArtistToken,'brucesp'),
                               "brucespringsteen"))
  
  #Code below used for unique list of artists. Not used here.
  #now that tokens are created extract unique ones for each dj so mulitples don't occur
  # the zillion flavors of "Sun Ra..." will show up for each DJ only once
  # not perfect.  There are a dozen ways Andy Breckman can misspell "Bruce Springsteen."
  #print("Create list of unique artist names for each DJ")
  #artistTokens<-allDJArtists%>%select(DJ,artistToken)%>%group_by(DJ)%>%distinct(artistToken)


  print("Combining iconic 2-name artists into one name to save space in wordcloud")
  allDJArtists$ArtistToken<-str_replace_all(allDJArtists$ArtistToken,"rollingstones","stones")
  allDJArtists$ArtistToken<-str_replace_all(allDJArtists$ArtistToken,"enniomorricone","morricone") #only on WFMU!
  allDJArtists$ArtistToken<-str_replace_all(allDJArtists$ArtistToken,"davidbowie","bowie")
  allDJArtists$ArtistToken<-str_replace_all(allDJArtists$ArtistToken,"bobdylan","dylan")
  allDJArtists$ArtistToken<-str_replace_all(allDJArtists$ArtistToken,"yola","yolatengo")
  
  allDJArtists<-allDJArtists %>% 
    select(DJ,AirDate,Artist=ArtistRaw,Title,ArtistToken) %>% 
    mutate(DJ=as.factor(DJ)) %>% 
    filter(Artist != "Music Behind Dj:")
    group_by(DJ) 
```
Data is reasonably clean.  Do some analysis
```{r}

#-------------------------------------------------------------------------------------
  #allDJArtists %>% summarise(song_count=n()) %>% arrange(desc(song_count))
#scalefactor magnifies differences for wordcloud
scaleFactor=2
maxWords = 200
  #most popular artists
  top_artists<-allDJArtists%>%group_by(ArtistToken)%>%
    summarize(play_count=n())%>%
    arrange(desc(play_count))
wordcloud(words = top_artists$ArtistToken, freq = top_artists$play_count^scaleFactor,max.words=maxWords, random.order=FALSE,rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"),scale = c(3,.3))
  #most popular artists in last year
  top_artists<-allDJArtists%>% filter(AirDate>Sys.Date()-365) %>% 
    group_by(ArtistToken)%>%
    summarize(play_count=n())%>%
    arrange(desc(play_count))
  
wordcloud(words = top_artists$ArtistToken, freq = top_artists$play_count^scaleFactor,max.words=maxWords, random.order=FALSE,rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"),scale = c(3,.3))
  
```

combine artist list into a single string per DJ
```{r}
#-------------------------------------------------------------  
#combineAllArtists
  concat_artists<- data_frame()
  #make sure there aren't extra levels
  allDJArtists$DJ<-factor(allDJArtists$DJ,as.character(unique(allDJArtists$DJ)))
  for (dj in levels(allDJArtists$DJ)){
    #put all words in string for each DJ
    print(paste("Creating artist documents",dj))
  concat_artists<-bind_rows(concat_artists,data_frame(DJ=dj,
                        Artists= allDJArtists%>%
                          filter(DJ==dj)%>%
                          pull(ArtistToken)%>% 
                          paste(collapse=" ")%>%
                          str_replace_all("[^a-z ]","")%>%as.character(),
                        onSched=DJKey%>%filter(DJ==dj)%>%pull(onSched)))
  }
  #artists should not have factor levels
  #concat_artists$Artists<-as.character(concat_artists$Artists)
  concat_artists<-filter(concat_artists,Artists!="")
```

````{r}
#------------------------------------------------------------
delete.isolates <- function(graph) {
  #isolates <- which(degree(graph, mode = mode) == 0) - 1
  #delete.vertices(graph, isolates)
  return(delete.vertices(graph,V(graph)[degree(graph)==0]))
}
#-----------------------------------------------------------
jaccard <- function(m) {
  #http://stackoverflow.com/questions/36220585/efficient-jaccard-similarity-documenttermmatrix
  ## common values:
  A <- tcrossprod(m)
  im <- which(A > 0, arr.ind=TRUE, useNames = FALSE)
  b <- rowSums(m)
  Aim <- A[im]
  J<-sparseMatrix(
    i = im[,1],
    j = im[,2],
    x = Aim / (b[im[,1]] + b[im[,2]] - Aim),
    dims = dim(A)
  )
  
  #preserve row/column names, if any
  rownames(J)<-rownames(m)
  colnames(J)<-rownames(m)
  return( J )
}  
#-----------------------------------------------------------
getSimilarity<-function(djdtm=djdtm){
  m2<-as.matrix(djdtm)
  rownames(m2)<-djDocs$DJ

  # get similarity
  #j<-simil(m2,method="Jaccard")
  j<-jaccard(m2)
  save(j,file="djSimilarity.RData")
  return(j)
}
#-----------------------------------------------------------
assignClusters<-function(j,CLUSTERS=5) {

  #j<-getSimilarity(djCorpus)
  
  # find similarity clusters
  #make a plot
  set.seed(1)
  kdj<-kmeans(j,CLUSTERS)
  clust<-kdj$cluster
  #djCluster<-cbind(DJ=names(clust),data.frame(cluster=clust))
  
  #if ("cluster" %in% names(DJKey)){
  #  # then remove the cluster column
  #  DJKey<-select(DJKey,-cluster)
  #}
  # now replace with new clustering
  #DJKey<-inner_join(DJKey,djCluster)%>%arrange(cluster)
    
  
  clusplot(as.matrix(j), clust, main="DJ Similiarity Clusters",color=T, shade=T, labels=2, lines=0) 
  #autoplot(kdj,data=j)
  #list DJ clusters
  #return (clust)
}
#----------------------------------------------------------
similarDJs<-function(whichDJ="TW",compareDJ="TM",j,DJKey,artistTokens){
  #djs for example
  #whichDJ <- "TW"
  #compareDJ<-"TM"
  likeDJs<-data.frame(similarity=as.matrix(j)[whichDJ,])
  #likeDJs<-likeDJs%>%add_rownames(var="DJ")
  likeDJs$DJ<-rownames(likeDJs)
  likeDJs<-arrange(likeDJs,desc(similarity))[-1,] #sort descending and remove self DJ
  rownames(likeDJs)<-NULL
  #since we sorted in order of descending similarity the first row has the most similar DJ
  compareDJ<-likeDJs[1,"DJ"]
  whichShow<-DJKey%>%filter(DJ==whichDJ)%>%.$ShowName%>%as.character()
  compareShow<-DJKey%>%filter(DJ==compareDJ)%>%.$ShowName%>%as.character()
  print(paste(whichShow,"is most similar to",compareShow))
  print(paste("Similarity Index:",format(likeDJs[1,"similarity"],digits=2),"/1.00"))
  commonArtists<-intersect(artistTokens[which(artistTokens$DJ==whichDJ),]$ArtistToken,artistTokens[which(artistTokens$DJ==compareDJ),]$ArtistToken)
  print(data.frame(Common_Artists=sample(commonArtists,20)))
}
#------------------------------------------------------------
#not functional
plotNetwork <- function(docMatrix) {
  library(proxy)
  library(igraph)
  #put DJs in rows, artists in columns
  idx <- meta(djCorpus, "onMic") == TRUE
  djdtm<-DocumentTermMatrix(djCorpus[idx]) %>% removeSparseTerms(0.8)
  m2<-as.matrix(djdtm)
  rownames(m2)<-djDocs$DJ[which(djDocs$onMic==TRUE)]
  save(m2,file="docTermMatrix.RData")
  
  #get euclidean distance
  # d<-dist(m2)
  #j<-jaccard(m2)
  j<-simil(m2,method="Jaccard")
  
  
  # find similarity clusters
  CLUSTERS<-5
  #make a plot
  clust<-kmeans(j,CLUSTERS)$cluster
  djCluster<-cbind(DJ=names(clust),data.frame(cluster=clust))
  temp<-arrange(inner_join(DJKey,djCluster),cluster)

  
  clusplot(as.matrix(j), clust, main="DJ Similiarity Clusters",color=T, shade=T, labels=2, lines=0) 
  #list DJ clusters
  
  #djs for example
  whichDJ <- "TW"
  compareDJ<-"TM"
  likeDJs<-data.frame(similarity=as.matrix(j)[whichDJ,])
  #likeDJs<-likeDJs%>%add_rownames(var="DJ")
  likeDJs$DJ<-rownames(likeDJs)
  likeDJs<-arrange(likeDJs,desc(similarity))[-1,] #sort descending and remove self DJ
  rownames(likeDJs)<-NULL  
  
  commonArtists<-intersect(artistTokens[which(artistTokens$DJ==whichDJ),]$ArtistToken,artistTokens[which(artistTokens$DJ==compareDJ),]$ArtistToken)
  sample(commonArtists,20)
  
  
  # create graph
  g<-as.matrix(j)%>%melt()%>%as.data.frame()%>%graph.data.frame()
  
  #create document matrix of commonalities
  #docMatrix<-m2 %*% t(m2)
  # get rid of DJs with no association to anybody after making matrix sparse
  # if complete matrix is used this will have no effect
  #orphans<-row.names(docMatrix[rowSums(docMatrix)==0,])
  #print(orphans)
  #docMatrix<-docMatrix[rowSums(docMatrix)!=0,rowSums(docMatrix)!=0]
  # build a graph from the above matrix
  #g <- graph.adjacency(docMatrix, weighted=T, mode = "undirected")
  # remove loops
  g <- simplify(g)
  #set labels and degrees of vertices
  V(g)$label <- V(g)$name
  V(g)$degree <- degree(g)
  E(g)$weight<-E(g)$value
  
  #remove edges with similarity less than 0.1 Jaccard
  g2 <- delete.edges(g, which(E(g)$value <0.10))
  g2<-delete.isolates(g2)
  # set seed to make the layout reproducible
  set.seed(3952)
  layout1 <- layout.fruchterman.reingold(g2)
  plot(g2, layout=layout1)
  
  #if we want to export to gephis plot tool
  library(rgexf) 
  wfmugraph<-igraph.to.gexf(g2)
  print(wfmugraf,file="wfmugraf.gexf")
  
}
#--------------------------------------------------------------------------------------------------
makeWordCloud<-function(djtdm=djtdm,maxWords=100) {
  #for wordcloud of most widely played artists
  #removing sparse terms at 0.99 means that artists played by fewer than 50 DJs will be dropped
  #and will return about 400 artists
  
  #just onMic?
  #idx <- meta(djCorpus, "cluster") == 5
  #djtdm<-TermDocumentMatrix(djCorpus[idx])%>%removeSparseTerms(0.80)
  
  
  m <- as.matrix(djtdm)
  
  v <- sort(rowSums(m),decreasing=TRUE)
  d <- data.frame(word = names(v),freq=v)
  t<-head(d, 200)
  rownames(t)<-NULL
  print(t)
  #save(t,file='artistfreq.txt',ascii = TRUE)
  
  print("Create Word Cloud")
  #scalefactor magnifies differences for wordcloud
  scaleFactor=3
  maxWords = 200
  allDJArtists%>%group_by(artist)%>%summarize(count=n())%>%arrange(desc(count)) ->artist_count
  wordcloud(words = artist_count$Artist, freq = artist_count$count^scaleFactor,max.words=maxWords, random.order=FALSE,rot.per=0.35, 
            colors=brewer.pal(8, "Dark2"),scale = c(3,.3))
  
}
#------------------------------------------------------------------
#plot stuff depending on onmic or offmic status
plotStuff<-function(djtdm=djdtm,j=j,DJKey=DJkey){
  print(ggplot(DJKey[1:20,],aes(ShowName,artistCount))+geom_bar(stat="identity")+coord_flip())
  makeWordCloud(djtdm)
  assignClusters(j)
  #print(DJKey$ShowName)
}  
# --------------------------------------------------------------------------- MAIN --------------
load("allDJArtists.RData")

# allDJArtists<-cleanUpArtists(allDJArtists)
# 
# #combine first numWords words in artist name into a single token
# artistTokens<-combineArtistWords(allDJArtists,numWords=2)
# 
# 
# load("DJKey.RData")
# 
#DJKey<-addArtistCount(DJKey,artistTokens)
# #save(DJKey,file="DJKey.RData")
# 
# #get rid of DJs with less than 100 artists, ever.  Probably not a music show
DJKey<-filter(DJKey,artistCount>100)
artistTokens<-semi_join(artistTokens,DJKey)
#regroup
artistTokens<-artistTokens%>%group_by(DJ)
# 
save(artistTokens,file="artistTokens.RData")
load("artistTokens.RData")
# 
# 
# #combine words into one document per DJ
# # don't try to display djDocs. It's a monster and will hang machine!
# djDocs<-combineAllArtists()
# save(djDocs,file="djDocs.RData")
# load("djDocs.RData")
# 

#--------------------------------------------------------------------------------
print("Create document corpus and term document matrices")
djCorpus <- Corpus(VectorSource(djDocs$Artists))


for (i in 1:length(djCorpus)) {
  meta(djCorpus[[i]], tag="ID") <- djDocs$DJ[i]  
  meta(djCorpus[[i]], tag="id") <- djDocs$DJ[i]  
  meta(djCorpus[[i]], tag="DJ") <- djDocs$DJ[i]
  meta(djCorpus[[i]], tag="onMic") <- djDocs$onMic[i]
}



micStatus=c("on","off","all")
mic<-micStatus[2]
#idx <- switch(mic,
#              on = (meta(djCorpus, "onMic") == TRUE),
#              off = (meta(djCorpus, "onMic") == FALSE),
#              both = rep(TRUE,length(djCorpus))
#              )


#djtdm<-TermDocumentMatrix(djCorpus[idx])%>%removeSparseTerms(SPARSE)

#OR if you have the memory to pre-create
#make 3 Term Document Matrices where artist is in the column based on onmic status
#get roughly top 400 artists when removeSparseTerms(0.80) used. top 8000 when 0.95 sparse is used
SPARSE<- 0.95 #sparsity of term document matrices

djtdm_all<-TermDocumentMatrix(djCorpus)%>%removeSparseTerms(SPARSE)
djtdm_on<-TermDocumentMatrix(djCorpus[meta(djCorpus, "onMic") == TRUE])%>%removeSparseTerms(SPARSE)
djtdm_off<-TermDocumentMatrix(djCorpus[meta(djCorpus, "onMic") == FALSE])%>%removeSparseTerms(SPARSE)

# now create Document Term Matrix where DJs are the column
djdtm<-DocumentTermMatrix(djCorpus)%>%removeSparseTerms(SPARSE)

# get similarity index matrix using Jaccard
j<-getSimilarity(djdtm)

onDJs<- DJKey%>%filter(onMic==TRUE)%>%select(DJ)%>%unlist()%>%as.vector()
offDJs<-DJKey%>%filter(onMic==FALSE)%>%select(DJ)%>%unlist()%>%as.vector()
AllDJs<-DJKey%>%select(DJ)%>%unlist()%>%as.vector()
#-----------------------------------------------------------------
#plot stuff
switch(mic,
       on = plotStuff(djtdm_on,j[onDJs,onDJs],DJKey[DJKey$DJ%in%onDJs,]),
       off = plotStuff(djtdm_off,j[offDJs,offDJs],DJKey[DJKey$DJ%in%offDJs,]),
       all = plotStuff(djtdm_all,DJKey)
              )


#----------------------------------------------------------------------
# New MAIN
print("Create Word Cloud")
#scalefactor magnifies differences for wordcloud
scaleFactor=2
maxWords = 200
allDJArtists%>%group_by(Artist)%>%summarize(count=n())%>%arrange(desc(count)) ->artist_count
wordcloud(words = artist_count$Artist, freq = artist_count$count^scaleFactor,max.words=maxWords, random.order=FALSE,rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"),scale = c(3,.3))


```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).
